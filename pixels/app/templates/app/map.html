<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="csrf-token" content="{{ csrf_token }}">
  <title>Harita Se√ßimi (Tam Ekran)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      
      background: #0A1019;
      background-image: url("https://www.transparenttextures.com/patterns/stardust.png");
    }

    #mapImage {
      -webkit-mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
      mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
      
    }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #mapContainer {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    #mapImage {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #333;
    }
    
    #gridCanvas {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      cursor: crosshair;
    }
    
    #info {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial;
      z-index: 2;
    }
    
    #debug {
      position: absolute;
      bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 2;
      max-width: 300px;
    }
    
    /* Butonlar i√ßin ortak stil */
    .control-btn {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
      margin-left: 10px;
      transition: all 0.3s ease;
    }
    
    #purchaseBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background-color: #10B981;
      color: white;
      display: none;
    }
    
    #purchaseBtn:hover {
      background-color: #0D9F6E;
      transform: translateY(-2px);
    }
    
    #clearBtn {
      position: absolute;
      bottom: 20px;
      right: 160px; /* Satƒ±n Al butonunun soluna yerle≈ütir */
      background-color: #EF4444;
      color: white;
      display: none;
    }
    
    #clearBtn:hover {
      background-color: #DC2626;
      transform: translateY(-2px);
    }
    
  </style>
</head>
<div id="tooltip" hidden
     style="
      position:fixed; z-index:1000; pointer-events:none;
      background: rgba(17,24,39,.95); color:#fff; 
      padding:12px 14px; border-radius:10px; 
      box-shadow:0 12px 28px rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.08); 
      max-width:280px; font: 13px/1.5 ui-sans-serif,system-ui;">
</div>
<body>
  <div id="container">
    <div id="mapContainer">
      <img id="mapImage" src="/static/app/map5.png" />
      <canvas id="gridCanvas"></canvas>
    </div>
    <div id="info">
      <div>Se√ßilen H√ºcre: <span id="selectedCount">0</span></div>
      <div>Son Tƒ±klama: <span id="lastClick">-</span></div>
    </div>
    <div id="debug">
      <div id="debugText">Harita y√ºkleniyor...</div>
    </div>
    <button id="clearBtn" class="control-btn">
      Se√ßimi Temizle
    </button>
    <button id="purchaseBtn" class="control-btn">
      Satƒ±n Al
    </button>
  </div>

  <script>
    const tooltipEl = document.getElementById('tooltip');
    let logoRegions = []; // {x,y,w,h, meta:{ company_name, notes, owner, purchased_at, logo_url }}

    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const selected = new Set();
    const purchaseBtn = document.getElementById("purchaseBtn");
    const clearBtn = document.getElementById("clearBtn");
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

    const cols = 400;
    const rows = 250;

    const img = document.getElementById("mapImage");
    const selectedCountEl = document.getElementById("selectedCount");
    const lastClickEl = document.getElementById("lastClick");
    const debugEl = document.getElementById("debugText");

    let imageDataCanvas = null;
    let imageCtx = null;
    let imageData = null;
    let imageScale = 1;
    let imageOffsetX = 0;
    let imageOffsetY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragCurrentX = 0;
    let dragCurrentY = 0;

    let purchasedCells = new Set();
    let selectedCells = new Set();

    function getVisibleSize() {
  return {
    visibleWidth:  img.naturalWidth * imageScale,
    visibleHeight: img.naturalHeight * imageScale
  };
}

function cellToScreenRect(col, row) {
  const { visibleWidth, visibleHeight } = getVisibleSize();
  const cellW = visibleWidth / cols;
  const cellH = visibleHeight / rows;
  const x = imageOffsetX + col * cellW;
  const y = imageOffsetY + row * cellH;
  return { x, y, w: cellW, h: cellH };
}

    // Fonksiyonlarƒ± en ba≈üta tanƒ±mla
    function colorCellGreen(key) {
      // Canvas √ºzerinde ye≈üil renk g√∂ster - satƒ±n alƒ±nan h√ºcreler i√ßin
      console.log("üü¢ H√ºcre ye≈üile boyandƒ±:", key);
    }

    function showTooltip(html, x, y) {
  tooltipEl.innerHTML = html;
  tooltipEl.hidden = false;

  // Ekran dƒ±≈üƒ±na ta≈ümasƒ±n
  const pad = 12;
  const rect = tooltipEl.getBoundingClientRect();
  let left = x + 16;
  let top  = y + 16;

  if (left + rect.width + pad > window.innerWidth)  left = x - rect.width - 16;
  if (top  + rect.height + pad > window.innerHeight) top  = y - rect.height - 16;

  tooltipEl.style.left = `${left}px`;
  tooltipEl.style.top  = `${top}px`;
}
function hideTooltip(){ tooltipEl.hidden = true; }


    function colorCellBlue(key) {
      // Canvas √ºzerinde mavi renk g√∂ster - se√ßili h√ºcreler i√ßin
      console.log("üîµ H√ºcre maviye boyandƒ±:", key);
    }

    async function fetchPurchasedCells() {
      try {
        const res = await fetch("/api/purchased");
        const data = await res.json();

        if (res.ok && Array.isArray(data.cells)) {
          for (const cell of data.cells) {
            purchasedCells.add(cell);
            colorCellGreen(cell);
          }
          console.log("‚úÖ Daha √∂nce satƒ±n alƒ±nan h√ºcreler y√ºklendi:", data.cells);
          draw(); // Canvas'ƒ± g√ºncelle
        } else {
          console.error("‚ùå H√ºcre verisi hatalƒ±:", data);
        }
      } catch (err) {
        console.error("‚ùå H√ºcreleri √ßekerken hata:", err);
      }
    }

    
    async function fetchSelectedCells() {
      try {
        const res = await fetch("/api/selected-cells");
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data.cells)) {
            for (const cell of data.cells) {
              selected.add(cell);
            }
            console.log("‚úÖ Daha √∂nce se√ßilen h√ºcreler y√ºklendi:", data.cells);
            draw(); // Canvas'ƒ± g√ºncelle
          }
        }
      } catch (err) {
        console.error("‚ùå Se√ßili h√ºcreleri √ßekerken hata:", err);
      }
    }

async function renderPurchasedLogos(ctx) {
  logoRegions = [];

  const response = await fetch("/api/purchased-cells");
  const data = await response.json();
  const cellData = data.detailed_data || [];

  // logo_url'e g√∂re grupla
  const logoGroups = {};
  for (const item of cellData) {
    if (!item.logo_url) continue;
    const key = item.logo_url;
    if (!logoGroups[key]) logoGroups[key] = { cells: [], meta: item };
    logoGroups[key].cells.push(item.cell);
  }

  const { visibleWidth, visibleHeight } = getVisibleSize();
  const cellW = visibleWidth / cols;
  const cellH = visibleHeight / rows;

  for (const [logoUrl, group] of Object.entries(logoGroups)) {
    const cells = group.cells;
    const meta  = group.meta;

    // Ekran koordinatlarƒ±na ta≈üƒ±
    const coords = cells.map(c => {
      const [x, y] = c.split(',').map(Number);
      return { col: x, row: y, ...cellToScreenRect(x, y) };
    });
    if (!coords.length) continue;

    // Kapsayan dikd√∂rtgen
    const minX = Math.min(...coords.map(c => c.x));
    const maxX = Math.max(...coords.map(c => c.x + c.w));
    const minY = Math.min(...coords.map(c => c.y));
    const maxY = Math.max(...coords.map(c => c.y + c.h));
    const screenX = minX, screenY = minY, screenW = maxX - minX, screenH = maxY - minY;

    // ‚ú® Clip alanƒ±: h√ºcrelerin birle≈üimi
    const clipPath = new Path2D();
    for (const c of coords) {
      // ekstra g√ºvenlik: sadece kara olan h√ºcreleri ekle
      if (isLandCell(c.col, c.row)) {
        clipPath.rect(c.x, c.y, c.w, c.h);
      }
    }

    // Tooltip i√ßin b√∂lgeyi kaydet (kapsayan dikd√∂rtgen yeterli)
    logoRegions.push({
      x: screenX, y: screenY, w: screenW, h: screenH,
      meta: {
        logo_url: logoUrl.startsWith("/logos/")
          ? logoUrl.replace("/logos/", "/media/logos/")
          : logoUrl,
        owner: meta.owner,
        company_name: meta.company_name,
        notes: meta.notes,
        purchased_at: meta.purchased_at
      }
    });

    // Logoyu sadece clip alanƒ±nda g√∂ster
    const urlFixed = logoRegions[logoRegions.length - 1].meta.logo_url;
    await new Promise(resolve => {
      const imgLogo = new Image();
      imgLogo.src = urlFixed;
      imgLogo.onload = () => {
        ctx.save();
        ctx.clip(clipPath);           // üß© sadece kara/se√ßili h√ºcreler
        ctx.globalAlpha = 0.9;
        ctx.drawImage(imgLogo, screenX, screenY, screenW, screenH);
        ctx.globalAlpha = 1.0;
        ctx.restore();
        resolve();
      };
      imgLogo.onerror = resolve; // hata olsa bile √ßizimi bloklamasƒ±n
    });
  }
}


    async function handlePurchase(csrfToken) {
      try {
        const purchaseRes = await fetch("/api/purchase", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken
          },
          credentials: "same-origin",
          body: JSON.stringify({
            logo_url: "https://example.com/logo.png"
          })
        });

        const result = await purchaseRes.json();

        if (purchaseRes.ok && result.status === "success") {
          alert("üéâ Satƒ±n alma ba≈üarƒ±lƒ±!\n" + result.message);

          // Satƒ±n alƒ±nan h√ºcreleri ye≈üil yap
          for (const cell of result.cells) {
            purchasedCells.add(cell);
            selected.delete(cell); // Satƒ±n alƒ±nan h√ºcreleri se√ßimden √ßƒ±kar
          }

          draw(); // Canvas'ƒ± g√ºncelle

        } else {
          alert("‚ùå Satƒ±n alma ba≈üarƒ±sƒ±z:\n" + (result.error || "Hata olu≈ütu"));
          console.log("Satƒ±n alma hatasƒ±:", result);
        }

      } catch (err) {
        alert("‚ùå Sunucuya eri≈üilemedi: " + err.message);
        console.error("Fetch hatasƒ±:", err);
      }
    }

    function clearSelection() {
      selected.clear();
      console.log("üóëÔ∏è T√ºm se√ßimler temizlendi");
      draw();
    }
function resize() {
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // CSS boyutu
  const cssW = window.innerWidth;
  const cssH = window.innerHeight;

  // Canvas ger√ßek piksel boyutu (DPR ile)
  canvas.width  = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);

  // CSS boyutunu koru ki layout bozulmasƒ±n
  canvas.style.width  = cssW + "px";
  canvas.style.height = cssH + "px";

  // T√ºm √ßizimleri CSS piksel koordinatƒ±yla yapabilelim:
  const ctx2d = ctx; // sadece okunaklƒ±lƒ±k
  ctx2d.setTransform(DPR, 0, 0, DPR, 0, 0);

  // Smoothing kalite
  ctx2d.imageSmoothingEnabled = true;
  ctx2d.imageSmoothingQuality = "high";

  if (img.naturalWidth > 0 && img.naturalHeight > 0) {
    const scaleW = cssW / img.naturalWidth;
    const scaleH = cssH / img.naturalHeight;
    imageScale   = Math.max(scaleW, scaleH); // COVER

    imageOffsetX = (cssW - img.naturalWidth  * imageScale) / 2;
    imageOffsetY = (cssH - img.naturalHeight * imageScale) / 2;

    if (!imageDataCanvas) {
      imageDataCanvas = document.createElement("canvas");
      imageDataCanvas.width  = img.naturalWidth;
      imageDataCanvas.height = img.naturalHeight;
      imageCtx = imageDataCanvas.getContext("2d");
      imageCtx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
      imageData = imageCtx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);
    }
  }

  debugEl.textContent =
    `Harita: ${img.naturalWidth}x${img.naturalHeight} | Canvas(CSS): ${cssW}x${cssH} | DPR: ${Math.round(DPR*100)/100} | Scale: ${imageScale.toFixed(3)} | off=(${imageOffsetX.toFixed(1)}, ${imageOffsetY.toFixed(1)})`;

  draw();
}



    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const visibleWidth = img.naturalWidth * imageScale;
      const visibleHeight = img.naturalHeight * imageScale;
      
      const cellW = visibleWidth / cols;
      const cellH = visibleHeight / rows;

      // 1. √ñNCE LOGOLARI √áƒ∞Z (en altta olsun)
      renderPurchasedLogos(ctx, visibleWidth / cols);

      // 2. SONRA SE√áƒ∞Lƒ∞ VE SATIN ALINAN H√úCRELERƒ∞ √áƒ∞Z
      // Se√ßili h√ºcreleri mavi renkte g√∂ster (hen√ºz satƒ±n alƒ±nmamƒ±≈ü)
      ctx.fillStyle = "rgba(59, 130, 246, 0.6)"; // Mavi
      ctx.strokeStyle = "rgba(59, 130, 246, 0.8)";
      ctx.lineWidth = 1;

      selected.forEach(key => {
        if (!purchasedCells.has(key)) { // Sadece satƒ±n alƒ±nmamƒ±≈ü h√ºcreleri g√∂ster
          const [x, y] = key.split(',').map(Number);
          const screenX = imageOffsetX + (x * cellW);
          const screenY = imageOffsetY + (y * cellH);
          
          if (screenX + cellW > 0 && screenX < canvas.width && 
              screenY + cellH > 0 && screenY < canvas.height) {
            ctx.fillRect(screenX, screenY, cellW, cellH);
            ctx.strokeRect(screenX, screenY, cellW, cellH);
          }
        }
      });

      // Satƒ±n alƒ±nan h√ºcreleri ye≈üil renkte g√∂ster
      ctx.fillStyle = "rgba(34, 197, 94, 0.8)"; // Ye≈üil
      ctx.strokeStyle = "rgba(34, 197, 94, 1)";
      ctx.lineWidth = 2;

      purchasedCells.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        const screenX = imageOffsetX + (x * cellW);
        const screenY = imageOffsetY + (y * cellH);
        
        if (screenX + cellW > 0 && screenX < canvas.width && 
            screenY + cellH > 0 && screenY < canvas.height) {
          ctx.fillRect(screenX, screenY, cellW, cellH);
          ctx.strokeRect(screenX, screenY, cellW, cellH);
        }
      });

      // 3. EN SON GRID √áƒ∞ZGƒ∞LERƒ∞Nƒ∞ √áƒ∞Z (en √ºstte olsun)
      if (cellW > 1 && cellH > 1) {
        ctx.strokeStyle = "rgba(28, 25, 25, 0.5)";
        ctx.lineWidth = 1;
        
        for (let x = 0; x <= cols; x++) {
          const screenX = imageOffsetX + (x * cellW);
          if (screenX >= 0 && screenX <= canvas.width) {
            ctx.beginPath();
            ctx.moveTo(screenX, Math.max(0, imageOffsetY));
            ctx.lineTo(screenX, Math.min(canvas.height, imageOffsetY + visibleHeight));
            ctx.stroke();
          }
        }
        
        for (let y = 0; y <= rows; y++) {
          const screenY = imageOffsetY + (y * cellH);
          if (screenY >= 0 && screenY <= canvas.height) {
            ctx.beginPath();
            ctx.moveTo(Math.max(0, imageOffsetX), screenY);
            ctx.lineTo(Math.min(canvas.width, imageOffsetX + visibleWidth), screenY);
            ctx.stroke();
          }
        }
      }

      // S√ºr√ºkleme sƒ±rasƒ±nda g√∂sterilecek dikd√∂rtgen
      if (isDragging) {
        const minX = Math.min(dragStartX, dragCurrentX);
        const minY = Math.min(dragStartY, dragCurrentY);
        const width = Math.abs(dragCurrentX - dragStartX);
        const height = Math.abs(dragCurrentY - dragStartY);

        ctx.strokeStyle = "rgba(255,255,0,0.8)";
        ctx.fillStyle = "rgba(255,255,0,0.2)";
        ctx.lineWidth = 2;
        
        ctx.fillRect(minX, minY, width, height);
        ctx.strokeRect(minX, minY, width, height);
      }

      selectedCountEl.textContent = selected.size;
      updateButtonVisibility();
    }

    function updateButtonVisibility() {
      const hasSelection = selected.size > 0;
      purchaseBtn.style.display = hasSelection ? "block" : "none";
      clearBtn.style.display = hasSelection ? "block" : "none";
    }

    function screenToGrid(screenX, screenY) {
      const imageX = (screenX - imageOffsetX) / imageScale;
      const imageY = (screenY - imageOffsetY) / imageScale;
      
      const col = Math.floor((imageX / img.naturalWidth) * cols);
      const row = Math.floor((imageY / img.naturalHeight) * rows);
      
      return [col, row];
    }

    function isLandCell(col, row) {
      if (!imageData || !imageDataCanvas) return true;
      if (col < 0 || col >= cols || row < 0 || row >= rows) return false;
      
      const pixelList = [
        [0, 0],
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1]
      ];

      let totalBrightness = 0;
      let validCount = 0;

      for (const [dx, dy] of pixelList) {
        const sampleX = Math.floor((col + 0.5 + dx) * (imageDataCanvas.width / cols));
        const sampleY = Math.floor((row + 0.5 + dy) * (imageDataCanvas.height / rows));

        if (sampleX < 0 || sampleX >= imageDataCanvas.width ||
            sampleY < 0 || sampleY >= imageDataCanvas.height) continue;

        const index = (sampleY * imageDataCanvas.width + sampleX) * 4;
        const r = imageData.data[index];
        const g = imageData.data[index + 1];
        const b = imageData.data[index + 2];

        const brightness = (r + g + b) / 3;
        totalBrightness += brightness;
        validCount++;
      }

      if (validCount === 0) return false;
      const avgBrightness = totalBrightness / validCount;
      return avgBrightness > 100;
    }

    function selectRectangleArea(startX, startY, endX, endY) {
      const [startCol, startRow] = screenToGrid(startX, startY);
      const [endCol, endRow] = screenToGrid(endX, endY);
      
      const minCol = Math.max(0, Math.min(startCol, endCol));
      const maxCol = Math.min(cols - 1, Math.max(startCol, endCol));
      const minRow = Math.max(0, Math.min(startRow, endRow));
      const maxRow = Math.min(rows - 1, Math.max(startRow, endRow));
      
      for (let col = minCol; col <= maxCol; col++) {
        for (let row = minRow; row <= maxRow; row++) {
          const key = `${col},${row}`;
          if (isLandCell(col, row) && !purchasedCells.has(key)) {
            selected.add(key);
          }
        }
      }
    }

    // Event listeners
    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      isDragging = true;
      dragStartX = x;
      dragStartY = y;
      dragCurrentX = x;
      dragCurrentY = y;
      
      e.preventDefault();
    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (isDragging) {
        dragCurrentX = x;
        dragCurrentY = y;
        draw(); 
      }

      const [col, row] = screenToGrid(x, y);
      let hovered = null;
for (let i = logoRegions.length - 1; i >= 0; i--) { // √ºstte olanƒ± √∂nce bul
  const r = logoRegions[i];
  if (x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h) { hovered = r; break; }
}

if (hovered) {
  const m = hovered.meta;
  const comp = m.company_name || "≈ûirket bilgisi yok";
  const ownr = m.owner ? `@${m.owner}` : "‚Äî";
  const note = m.notes ? `<div style='margin-top:6px; color:#cbd5e1'>${m.notes}</div>` : "";
  const when = m.purchased_at ? new Date(m.purchased_at).toLocaleDateString('tr-TR') : "";

  const html = `
    <div style="display:flex; gap:10px; align-items:flex-start">
      <img src="${m.logo_url}" alt="" style="width:40px; height:40px; object-fit:contain; background:#111827; border-radius:8px; border:1px solid rgba(255,255,255,.08)"/>
      <div>
        <div style="font-weight:700">${comp}</div>
        <div style="font-size:12px; opacity:.9">Sahip: ${ownr}${when ? " ‚Ä¢ " + when : ""}</div>
        ${note}
      </div>
    </div>`;
  showTooltip(html, e.clientX, e.clientY);
} else {
  hideTooltip();
}
    });

    canvas.addEventListener("mouseup", e => {
      if (isDragging) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const dragDistance = Math.abs(x - dragStartX) + Math.abs(y - dragStartY);

        if (dragDistance < 5) {
          const [col, row] = screenToGrid(x, y);
          const key = `${col},${row}`;
          lastClickEl.textContent = `(${col}, ${row})`;

          if (!isLandCell(col, row)) {
            console.log("üåä Bu h√ºcre deniz veya sƒ±nƒ±r dƒ±≈üƒ±, se√ßilemez.");
          } else if (purchasedCells.has(key)) {
            console.log("üü¢ Bu h√ºcre zaten satƒ±n alƒ±ndƒ±:", key);
          } else {
            if (selected.has(key)) {
              selected.delete(key);
              console.log("‚ùå H√ºcre se√ßimi kaldƒ±rƒ±ldƒ±:", key);
            } else {
              selected.add(key);
              console.log("‚úÖ H√ºcre se√ßildi:", key);
            }
          }
        } else {
          selectRectangleArea(dragStartX, dragStartY, x, y); 
          console.log("üì¶ Kutu alanƒ± se√ßildi");
        }

        isDragging = false;
        draw();
      }
    });

    canvas.addEventListener("mouseleave", e => {
      if (isDragging) {
        isDragging = false;
        draw();
      }
    });

    // Se√ßimi Temizle butonuna tƒ±klama
    clearBtn.addEventListener("click", () => {
      if (selected.size === 0) return;
      
      const confirmed = confirm(`${selected.size} se√ßili h√ºcreyi temizlemek istediƒüinizden emin misiniz?`);
      if (confirmed) {
        clearSelection();
      }
    });

    // Satƒ±n al butonuna tƒ±klama
    purchaseBtn.addEventListener("click", async () => {
      if (selected.size === 0) {
        alert("L√ºtfen √∂nce h√ºcre se√ßin.");
        return;
      }

      const cellsArray = Array.from(selected);

      try {
        const saveRes = await fetch("/api/save-selection", {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken
          },
          credentials: "same-origin",
          body: JSON.stringify({ cells: cellsArray })
        });

        const saveText = await saveRes.text();
        if (!saveRes.ok) {
          console.error("‚ùå Hata cevabƒ±:", saveText);
          alert("Hata: " + saveText);
          return;
        }

        const saveData = JSON.parse(saveText);
        console.log("‚úÖ H√ºcreler kaydedildi:", saveData);

        // Satƒ±n alma sayfasƒ±na y√∂nlendir
        const selectedCellsParam = encodeURIComponent(JSON.stringify(cellsArray));
        window.location.href = `/purchase?cells=${selectedCellsParam}&count=${cellsArray.length}`;

      } catch (err) {
        alert("‚ùå Sunucuya eri≈üilemedi: " + err.message);
        console.error("Fetch hatasƒ±:", err);
      }
    });
    
    img.addEventListener("load", () => {
      console.log("G√∂r√ºnt√º y√ºklendi:", img.naturalWidth, "x", img.naturalHeight);
      resize();
      fetchPurchasedCells(); 
      fetchSelectedCells(); // Se√ßili h√ºcreleri de y√ºkle
    });

    window.addEventListener("resize", resize);
    window.addEventListener("load", () => {
      resize();
    });
  </script>
</body>
</html>