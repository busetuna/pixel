<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="csrf-token" content="{{ csrf_token }}">
  <title>Harita SeÃ§imi (Tam Ekran)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      
      background: #0A1019;
      background-image: url("https://www.transparenttextures.com/patterns/stardust.png");
    }

    #mapImage {
      -webkit-mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
      mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
    }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #mapContainer {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    #mapImage {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover; /* EkranÄ± tam kaplamasÄ± iÃ§in cover kullan */
      background: #333;
    }
    
    #gridCanvas {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      cursor: crosshair;
    }
    
    #info {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial;
      z-index: 2;
    }
    
    #debug {
      position: absolute;
      bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 2;
      max-width: 300px;
    }
    
    #purchaseBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 12px 24px;
      font-size: 16px;
      background-color: #10B981;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
      display: none;
    }
    
    #purchaseBtn:hover {
      background-color: #0D9F6E;
    }
    
  </style>
</head>
<body>
  <div id="container">
    <div id="mapContainer">
      <img id="mapImage" src="/static/app/map5.png" />
      <canvas id="gridCanvas"></canvas>
    </div>
    <div id="info">
      <div>SeÃ§ilen HÃ¼cre: <span id="selectedCount">0</span></div>
      <div>Son TÄ±klama: <span id="lastClick">-</span></div>
    </div>
    <div id="debug">
      <div id="debugText">Harita yÃ¼kleniyor...</div>
    </div>
    <button id="purchaseBtn">
      âœ… SatÄ±n Al
    </button>
  </div>

  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const selected = new Set();
    const purchaseBtn = document.getElementById("purchaseBtn");
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

    const cols = 400; // 400 sÃ¼tun
    const rows = 250;

    const img = document.getElementById("mapImage");
    const selectedCountEl = document.getElementById("selectedCount");
    const lastClickEl = document.getElementById("lastClick");
    const debugEl = document.getElementById("debugText");

    let imageDataCanvas = null;
    let imageCtx = null;
    let imageData = null;
    let imageScale = 1;
    let imageOffsetX = 0;
    let imageOffsetY = 0;

    
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragCurrentX = 0;
    let dragCurrentY = 0;

    function resize() {
     
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

     
      if (img.naturalWidth > 0 && img.naturalHeight > 0) {
        const containerAspect = canvas.width / canvas.height;
        const imageAspect = img.naturalWidth / img.naturalHeight;
        
        if (containerAspect > imageAspect) {
        
          imageScale = canvas.width / img.naturalWidth;
          imageOffsetX = 0;
          imageOffsetY = (canvas.height - (img.naturalHeight * imageScale)) / 2;
        } else {
        
          imageScale = canvas.height / img.naturalHeight;
          imageOffsetX = (canvas.width - (img.naturalWidth * imageScale)) / 2;
          imageOffsetY = 0;
        }

        
        if (!imageDataCanvas) {
          imageDataCanvas = document.createElement("canvas");
          imageDataCanvas.width = img.naturalWidth;
          imageDataCanvas.height = img.naturalHeight;
          imageCtx = imageDataCanvas.getContext("2d");
          
       
          imageCtx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
          imageData = imageCtx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);
        }
      }

      debugEl.textContent = `Harita: ${img.naturalWidth}x${img.naturalHeight} | Canvas: ${canvas.width}x${canvas.height} | Scale: ${imageScale.toFixed(2)}`;
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      
      const visibleWidth = img.naturalWidth * imageScale;
      const visibleHeight = img.naturalHeight * imageScale;
      
      const cellW = visibleWidth / cols;
      const cellH = visibleHeight / rows;

      
      if (cellW > 1 && cellH > 1) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.19)"; // Daha gÃ¶rÃ¼nÃ¼r beyaz
        ctx.lineWidth = 1; // Daha kalÄ±n Ã§izgi
        
      
        for (let x = 0; x <= cols; x++) {
          const screenX = imageOffsetX + (x * cellW);
          if (screenX >= 0 && screenX <= canvas.width) {
            ctx.beginPath();
            ctx.moveTo(screenX, Math.max(0, imageOffsetY));
            ctx.lineTo(screenX, Math.min(canvas.height, imageOffsetY + visibleHeight));
            ctx.stroke();
          }
        }
        
       
        for (let y = 0; y <= rows; y++) {
          const screenY = imageOffsetY + (y * cellH);
          if (screenY >= 0 && screenY <= canvas.height) {
            ctx.beginPath();
            ctx.moveTo(Math.max(0, imageOffsetX), screenY);
            ctx.lineTo(Math.min(canvas.width, imageOffsetX + visibleWidth), screenY);
            ctx.stroke();
          }
        }
      }

    
      ctx.fillStyle = "rgba(34,197,94,0.6)";
      ctx.strokeStyle = "rgba(34,197,94,0.8)";
      ctx.lineWidth = 1;

      selected.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        const screenX = imageOffsetX + (x * cellW);
        const screenY = imageOffsetY + (y * cellH);
        
      
        if (screenX + cellW > 0 && screenX < canvas.width && 
            screenY + cellH > 0 && screenY < canvas.height) {
          ctx.fillRect(screenX, screenY, cellW, cellH);
          ctx.strokeRect(screenX, screenY, cellW, cellH);
        }
      });

    
      if (isDragging) {
        const minX = Math.min(dragStartX, dragCurrentX);
        const minY = Math.min(dragStartY, dragCurrentY);
        const width = Math.abs(dragCurrentX - dragStartX);
        const height = Math.abs(dragCurrentY - dragStartY);

        ctx.strokeStyle = "rgba(255,255,0,0.8)";
        ctx.fillStyle = "rgba(255,255,0,0.2)";
        ctx.lineWidth = 2;
        
        ctx.fillRect(minX, minY, width, height);
        ctx.strokeRect(minX, minY, width, height);
      }

      selectedCountEl.textContent = selected.size;
      updatePurchaseButtonVisibility();
    }

    function updatePurchaseButtonVisibility() {
      purchaseBtn.style.display = selected.size > 0 ? "block" : "none";
    }

    function screenToGrid(screenX, screenY) {
     
      const imageX = (screenX - imageOffsetX) / imageScale;
      const imageY = (screenY - imageOffsetY) / imageScale;
      
      const col = Math.floor((imageX / img.naturalWidth) * cols);
      const row = Math.floor((imageY / img.naturalHeight) * rows);
      
      return [col, row];
    }

    function isLandCell(col, row) {
      if (!imageData || !imageDataCanvas) return true;
      if (col < 0 || col >= cols || row < 0 || row >= rows) return false;
      
      const pixelList = [
        [0, 0],
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1]
      ];

      let totalBrightness = 0;
      let validCount = 0;

      for (const [dx, dy] of pixelList) {
        const sampleX = Math.floor((col + 0.5 + dx) * (imageDataCanvas.width / cols));
        const sampleY = Math.floor((row + 0.5 + dy) * (imageDataCanvas.height / rows));

        if (sampleX < 0 || sampleX >= imageDataCanvas.width ||
            sampleY < 0 || sampleY >= imageDataCanvas.height) continue;

        const index = (sampleY * imageDataCanvas.width + sampleX) * 4;
        const r = imageData.data[index];
        const g = imageData.data[index + 1];
        const b = imageData.data[index + 2];

        const brightness = (r + g + b) / 3;
        totalBrightness += brightness;
        validCount++;
      }

      if (validCount === 0) return false;
      const avgBrightness = totalBrightness / validCount;
      return avgBrightness > 100;
    }
    function colorCellGreen(key) {
  const [col, row] = key.split(',').map(Number);
  const cellElement = document.getElementById(`cell-${col}-${row}`);
  if (cellElement) {
    cellElement.style.backgroundColor = 'green';
    cellElement.style.pointerEvents = 'none';
    cellElement.style.opacity = '0.7';
  }
}
fetch('/api/purchased-cells')
  .then(res => res.json())
  .then(data => {
    purchasedCells = new Set(data.cells);
    for (const key of purchasedCells) {
      colorCellGreen(key);
    }
  });

    function selectRectangleArea(startX, startY, endX, endY) {
      const [startCol, startRow] = screenToGrid(startX, startY);
      const [endCol, endRow] = screenToGrid(endX, endY);
      
      const minCol = Math.max(0, Math.min(startCol, endCol));
      const maxCol = Math.min(cols - 1, Math.max(startCol, endCol));
      const minRow = Math.max(0, Math.min(startRow, endRow));
      const maxRow = Math.min(rows - 1, Math.max(startRow, endRow));
      
      for (let col = minCol; col <= maxCol; col++) {
        for (let row = minRow; row <= maxRow; row++) {
          if (isLandCell(col, row)) {
            const key = `${col},${row}`;
            selected.add(key);
          }
        }
      }
    }

    
    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      isDragging = true;
      dragStartX = x;
      dragStartY = y;
      dragCurrentX = x;
      dragCurrentY = y;
      
      e.preventDefault();
    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (isDragging) {
        dragCurrentX = x;
        dragCurrentY = y;
        draw(); 
      }

      const [col, row] = screenToGrid(x, y);
     
    });

    canvas.addEventListener("mouseup", e => {
      if (isDragging) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const dragDistance = Math.abs(x - dragStartX) + Math.abs(y - dragStartY);

        if (dragDistance < 5) {
          // Tek tÄ±klama
          const [col, row] = screenToGrid(x, y);
          const key = `${col},${row}`;
          lastClickEl.textContent = `(${col}, ${row})`;

          if (!isLandCell(col, row)) {
            console.log("ðŸŒŠ Bu hÃ¼cre deniz veya sÄ±nÄ±r dÄ±ÅŸÄ±, seÃ§ilemez.");
          } else {
            if (selected.has(key)) {
              selected.delete(key);
              console.log("âŒ HÃ¼cre seÃ§imi kaldÄ±rÄ±ldÄ±:", key);
            } else {
              selected.add(key);
              console.log("âœ… HÃ¼cre seÃ§ildi:", key);
            }
          }
        } else {
          // Kutu seÃ§imi
          selectRectangleArea(dragStartX, dragStartY, x, y); 
          console.log("ðŸ“¦ Kutu alanÄ± seÃ§ildi");
        }

        isDragging = false;
        draw();
      }
    });

  
    canvas.addEventListener("mouseleave", e => {
      if (isDragging) {
        isDragging = false;
        draw();
      }
    });

    // SatÄ±n al butonuna tÄ±klama
    purchaseBtn.addEventListener("click", async () => {
      if (selected.size === 0) {
        alert("LÃ¼tfen Ã¶nce hÃ¼cre seÃ§in.");
        return;
      }

      const cellsArray = Array.from(selected);

      try {
        const saveRes = await fetch("/api/save-selection", {
  method: "POST",
  headers: { "Content-Type": "application/json" ,
    "X-CSRFToken": csrfToken // CSRF token ekle
  },
  body: JSON.stringify({ cells: cellsArray })
});

const saveText = await saveRes.text(); // ilk olarak text al
if (!saveRes.ok) {
  console.error("âŒ Hata cevabÄ±:", saveText);
  alert("Hata: " + saveText);
  return;
}

const saveData = JSON.parse(saveText);

        if (!saveRes.ok) {
          alert("âŒ HÃ¼creleri kaydederken hata oluÅŸtu:\n" + (saveData.detail || saveData.message));
          return;
        }

        console.log("âœ… HÃ¼creler kaydedildi:", saveData);
let selectedCells = new Set();

try {
  const purchaseRes = await fetch("/api/purchase", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-CSRFToken": csrfToken
    },
    credentials: "same-origin",
    body: JSON.stringify({
      logo_url: "https://example.com/logo.png"
    })
  });

  const result = await purchaseRes.json();  // âœ… sadece bir kez .json()

  if (purchaseRes.ok && result.status === "success") {
    // ðŸŽ‰ KullanÄ±cÄ±ya mesaj gÃ¶ster
    alert("ðŸŽ‰ SatÄ±n alma baÅŸarÄ±lÄ±!\n" + result.message);

    // âœ… SatÄ±n alÄ±nan hÃ¼creleri yeÅŸile boya
    for (const cell of result.cells) {
      purchasedCells.add(cell);
      colorCellGreen(cell);
    }

    // ðŸ§¹ SeÃ§imi temizle
    selectedCells.clear(); // â† Set kullandÄ±ÄŸÄ±nÄ± varsayÄ±yorum
    draw(); // varsa grid'i yeniden Ã§iz

  } else {
    // âŒ Hata varsa kullanÄ±cÄ±ya mesaj gÃ¶ster
    alert("âŒ SatÄ±n alma baÅŸarÄ±sÄ±z:\n" + (result.error || "Hata oluÅŸtu"));
    console.log("SatÄ±n alma hatasÄ±:", result);
  }

} catch (err) {
  alert("âŒ Sunucuya eriÅŸilemedi: " + err.message);
  console.error("Fetch hatasÄ±:", err);
}


const result = await purchaseRes.json();

if (result.status === "success") {
  // ðŸŽ¯ Yeni satÄ±n alÄ±nan hÃ¼creleri Set'e ekle
  for (const cell of result.cells) {
    purchasedCells.add(cell);  // "10,12" gibi
    colorCellGreen(cell);      // Haritada yeÅŸil boya
  }

  // ðŸ§¹ SeÃ§ili hÃ¼creleri temizle (istersen)
  selectedCells.clear();
  //updateUI();
} else {
  alert("âŒ " + (result.error || "SatÄ±n alma baÅŸarÄ±sÄ±z"));
}



        const purchaseData = await purchaseRes.json();

        if (purchaseRes.ok) {
          alert("ðŸŽ‰ SatÄ±n alma baÅŸarÄ±lÄ±!\n" + purchaseData.message);
          selected.clear();
          draw();
        } else {
          alert("âŒ SatÄ±n alma baÅŸarÄ±sÄ±z:\n" + (purchaseData.error || "Hata"));
          console.log("SatÄ±n alma hatasÄ±:", purchaseData);
        }

      } catch (err) {
        alert("âŒ Sunucuya eriÅŸilemedi: " + err.message);
        console.error("Fetch hatasÄ±:", err);
      }
    });
    
    img.addEventListener("load", () => {
      console.log("GÃ¶rÃ¼ntÃ¼ yÃ¼klendi:", img.naturalWidth, "x", img.naturalHeight);
      resize();
    });

    
    window.addEventListener("resize", resize);

   
    window.addEventListener("load", () => {
      resize();
    });
  </script>
</body>
</html>