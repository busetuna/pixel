<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="csrf-token" content="{{ csrf_token }}">
  <title>Harita SeÃ§imi (Tam Ekran)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      
      background: #0A1019;
      background-image: url("https://www.transparenttextures.com/patterns/stardust.png");
    }

    #mapImage {
      -webkit-mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
      mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
    }
    
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #mapContainer {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    #mapImage {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #333;
    }
    
    #gridCanvas {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
      cursor: crosshair;
    }
    
    #info {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial;
      z-index: 2;
    }
    
    #debug {
      position: absolute;
      bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 2;
      max-width: 300px;
    }
    
    #purchaseBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 12px 24px;
      font-size: 16px;
      background-color: #10B981;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
      display: none;
    }
    
    #purchaseBtn:hover {
      background-color: #0D9F6E;
    }
    
  </style>
</head>
<body>
  <div id="container">
    <div id="mapContainer">
      <img id="mapImage" src="/static/app/map5.png" />
      <canvas id="gridCanvas"></canvas>
    </div>
    <div id="info">
      <div>SeÃ§ilen HÃ¼cre: <span id="selectedCount">0</span></div>
      <div>Son TÄ±klama: <span id="lastClick">-</span></div>
    </div>
    <div id="debug">
      <div id="debugText">Harita yÃ¼kleniyor...</div>
    </div>
    <button id="purchaseBtn">
      âœ… SatÄ±n Al
    </button>
  </div>

  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const selected = new Set();
    const purchaseBtn = document.getElementById("purchaseBtn");
    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

    const cols = 400;
    const rows = 250;

    const img = document.getElementById("mapImage");
    const selectedCountEl = document.getElementById("selectedCount");
    const lastClickEl = document.getElementById("lastClick");
    const debugEl = document.getElementById("debugText");

    let imageDataCanvas = null;
    let imageCtx = null;
    let imageData = null;
    let imageScale = 1;
    let imageOffsetX = 0;
    let imageOffsetY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragCurrentX = 0;
    let dragCurrentY = 0;

    let purchasedCells = new Set();
    let selectedCells = new Set();

    // FonksiyonlarÄ± en baÅŸta tanÄ±mla
    function colorCellGreen(key) {
      // Canvas Ã¼zerinde yeÅŸil renk gÃ¶ster - satÄ±n alÄ±nan hÃ¼creler iÃ§in
      console.log("ðŸŸ¢ HÃ¼cre yeÅŸile boyandÄ±:", key);
    }

    function colorCellBlue(key) {
      // Canvas Ã¼zerinde mavi renk gÃ¶ster - seÃ§ili hÃ¼creler iÃ§in
      console.log("ðŸ”µ HÃ¼cre maviye boyandÄ±:", key);
    }

    async function fetchPurchasedCells() {
      try {
        const res = await fetch("/api/purchased-cells");
        const data = await res.json();

        if (res.ok && Array.isArray(data.cells)) {
          for (const cell of data.cells) {
            purchasedCells.add(cell);
            colorCellGreen(cell);
          }
          console.log("âœ… Daha Ã¶nce satÄ±n alÄ±nan hÃ¼creler yÃ¼klendi:", data.cells);
          draw(); // Canvas'Ä± gÃ¼ncelle
        } else {
          console.error("âŒ HÃ¼cre verisi hatalÄ±:", data);
        }
      } catch (err) {
        console.error("âŒ HÃ¼creleri Ã§ekerken hata:", err);
      }
    }

    async function fetchSelectedCells() {
      try {
        const res = await fetch("/api/selected-cells");
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data.cells)) {
            for (const cell of data.cells) {
              selected.add(cell);
            }
            console.log("âœ… Daha Ã¶nce seÃ§ilen hÃ¼creler yÃ¼klendi:", data.cells);
            draw(); // Canvas'Ä± gÃ¼ncelle
          }
        }
      } catch (err) {
        console.error("âŒ SeÃ§ili hÃ¼creleri Ã§ekerken hata:", err);
      }
    }
async function renderPurchasedLogos(ctx, cellSize = 20) {
  const response = await fetch("/api/purchased-cells");
  const data = await response.json();
  const cellData = data.detailed_data;

  const logoGroups = {};

  for (const item of cellData) {
    if (!item.logo_url) continue;

    if (!logoGroups[item.logo_url]) {
      logoGroups[item.logo_url] = [];
    }

    logoGroups[item.logo_url].push(item.cell);
  }

  for (const [logoUrl, cells] of Object.entries(logoGroups)) {
    const coords = cells.map(cell => {
      const [x, y] = cell.split(',').map(Number);
      return { x, y };
    });

    if (coords.length === 0) continue;

    // ðŸ“ Kapsayan dikdÃ¶rtgeni bul
    const minX = Math.min(...coords.map(c => c.x));
    const maxX = Math.max(...coords.map(c => c.x));
    const minY = Math.min(...coords.map(c => c.y));
    const maxY = Math.max(...coords.map(c => c.y));

    const widthInCells = maxX - minX + 1;
    const heightInCells = maxY - minY + 1;

    const screenX = imageOffsetX + minX * (img.naturalWidth * imageScale / cols);
    const screenY = imageOffsetY + minY * (img.naturalHeight * imageScale / rows);
    const screenW = widthInCells * (img.naturalWidth * imageScale / cols);
    const screenH = heightInCells * (img.naturalHeight * imageScale / rows);

    const imgLogo = new Image();
    imgLogo.src = logoUrl.startsWith("/logos/")
      ? logoUrl.replace("/logos/", "/media/logos/")
      : logoUrl;

    imgLogo.onload = () => {
      ctx.globalAlpha = 0.9;
      ctx.drawImage(imgLogo, screenX, screenY, screenW, screenH);
      ctx.globalAlpha = 1.0;
    };
  }
}


    async function handlePurchase(csrfToken) {
      try {
        const purchaseRes = await fetch("/api/purchase", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken
          },
          credentials: "same-origin",
          body: JSON.stringify({
            logo_url: "https://example.com/logo.png"
          })
        });

        const result = await purchaseRes.json();

        if (purchaseRes.ok && result.status === "success") {
          alert("ðŸŽ‰ SatÄ±n alma baÅŸarÄ±lÄ±!\n" + result.message);

          // SatÄ±n alÄ±nan hÃ¼creleri yeÅŸil yap
          for (const cell of result.cells) {
            purchasedCells.add(cell);
            selected.delete(cell); // SatÄ±n alÄ±nan hÃ¼creleri seÃ§imden Ã§Ä±kar
          }

          draw(); // Canvas'Ä± gÃ¼ncelle

        } else {
          alert("âŒ SatÄ±n alma baÅŸarÄ±sÄ±z:\n" + (result.error || "Hata oluÅŸtu"));
          console.log("SatÄ±n alma hatasÄ±:", result);
        }

      } catch (err) {
        alert("âŒ Sunucuya eriÅŸilemedi: " + err.message);
        console.error("Fetch hatasÄ±:", err);
      }
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      if (img.naturalWidth > 0 && img.naturalHeight > 0) {
        const containerAspect = canvas.width / canvas.height;
        const imageAspect = img.naturalWidth / img.naturalHeight;
        
        if (containerAspect > imageAspect) {
          imageScale = canvas.width / img.naturalWidth;
          imageOffsetX = 0;
          imageOffsetY = (canvas.height - (img.naturalHeight * imageScale)) / 2;
        } else {
          imageScale = canvas.height / img.naturalHeight;
          imageOffsetX = (canvas.width - (img.naturalWidth * imageScale)) / 2;
          imageOffsetY = 0;
        }

        if (!imageDataCanvas) {
          imageDataCanvas = document.createElement("canvas");
          imageDataCanvas.width = img.naturalWidth;
          imageDataCanvas.height = img.naturalHeight;
          imageCtx = imageDataCanvas.getContext("2d");
          
          imageCtx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
          imageData = imageCtx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);
        }
      }

      debugEl.textContent = `Harita: ${img.naturalWidth}x${img.naturalHeight} | Canvas: ${canvas.width}x${canvas.height} | Scale: ${imageScale.toFixed(2)}`;
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const visibleWidth = img.naturalWidth * imageScale;
      const visibleHeight = img.naturalHeight * imageScale;
      
      const cellW = visibleWidth / cols;
      const cellH = visibleHeight / rows;

      if (cellW > 1 && cellH > 1) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.19)";
        ctx.lineWidth = 1;
        
        for (let x = 0; x <= cols; x++) {
          const screenX = imageOffsetX + (x * cellW);
          if (screenX >= 0 && screenX <= canvas.width) {
            ctx.beginPath();
            ctx.moveTo(screenX, Math.max(0, imageOffsetY));
            ctx.lineTo(screenX, Math.min(canvas.height, imageOffsetY + visibleHeight));
            ctx.stroke();
          }
        }
        
        for (let y = 0; y <= rows; y++) {
          const screenY = imageOffsetY + (y * cellH);
          if (screenY >= 0 && screenY <= canvas.height) {
            ctx.beginPath();
            ctx.moveTo(Math.max(0, imageOffsetX), screenY);
            ctx.lineTo(Math.min(canvas.width, imageOffsetX + visibleWidth), screenY);
            ctx.stroke();
          }
        }
      }

      // SeÃ§ili hÃ¼creleri mavi renkte gÃ¶ster (henÃ¼z satÄ±n alÄ±nmamÄ±ÅŸ)
      ctx.fillStyle = "rgba(59, 130, 246, 0.6)"; // Mavi
      ctx.strokeStyle = "rgba(59, 130, 246, 0.8)";
      ctx.lineWidth = 1;

      selected.forEach(key => {
        if (!purchasedCells.has(key)) { // Sadece satÄ±n alÄ±nmamÄ±ÅŸ hÃ¼creleri gÃ¶ster
          const [x, y] = key.split(',').map(Number);
          const screenX = imageOffsetX + (x * cellW);
          const screenY = imageOffsetY + (y * cellH);
          
          if (screenX + cellW > 0 && screenX < canvas.width && 
              screenY + cellH > 0 && screenY < canvas.height) {
            ctx.fillRect(screenX, screenY, cellW, cellH);
            ctx.strokeRect(screenX, screenY, cellW, cellH);
          }
        }
      });

      // SatÄ±n alÄ±nan hÃ¼creleri yeÅŸil renkte gÃ¶ster
      ctx.fillStyle = "rgba(34, 197, 94, 0.8)"; // YeÅŸil
      ctx.strokeStyle = "rgba(34, 197, 94, 1)";
      ctx.lineWidth = 2;

      purchasedCells.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        const screenX = imageOffsetX + (x * cellW);
        const screenY = imageOffsetY + (y * cellH);
        
        if (screenX + cellW > 0 && screenX < canvas.width && 
            screenY + cellH > 0 && screenY < canvas.height) {
          ctx.fillRect(screenX, screenY, cellW, cellH);
          ctx.strokeRect(screenX, screenY, cellW, cellH);
        }
      });

      if (isDragging) {
        const minX = Math.min(dragStartX, dragCurrentX);
        const minY = Math.min(dragStartY, dragCurrentY);
        const width = Math.abs(dragCurrentX - dragStartX);
        const height = Math.abs(dragCurrentY - dragStartY);

        ctx.strokeStyle = "rgba(255,255,0,0.8)";
        ctx.fillStyle = "rgba(255,255,0,0.2)";
        ctx.lineWidth = 2;
        
        ctx.fillRect(minX, minY, width, height);
        ctx.strokeRect(minX, minY, width, height);
      }

      selectedCountEl.textContent = selected.size;
      updatePurchaseButtonVisibility();
      renderPurchasedLogos(ctx, visibleWidth / cols); 
    }

    function updatePurchaseButtonVisibility() {
      purchaseBtn.style.display = selected.size > 0 ? "block" : "none";
    }

    function screenToGrid(screenX, screenY) {
      const imageX = (screenX - imageOffsetX) / imageScale;
      const imageY = (screenY - imageOffsetY) / imageScale;
      
      const col = Math.floor((imageX / img.naturalWidth) * cols);
      const row = Math.floor((imageY / img.naturalHeight) * rows);
      
      return [col, row];
    }

    function isLandCell(col, row) {
      if (!imageData || !imageDataCanvas) return true;
      if (col < 0 || col >= cols || row < 0 || row >= rows) return false;
      
      const pixelList = [
        [0, 0],
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1]
      ];

      let totalBrightness = 0;
      let validCount = 0;

      for (const [dx, dy] of pixelList) {
        const sampleX = Math.floor((col + 0.5 + dx) * (imageDataCanvas.width / cols));
        const sampleY = Math.floor((row + 0.5 + dy) * (imageDataCanvas.height / rows));

        if (sampleX < 0 || sampleX >= imageDataCanvas.width ||
            sampleY < 0 || sampleY >= imageDataCanvas.height) continue;

        const index = (sampleY * imageDataCanvas.width + sampleX) * 4;
        const r = imageData.data[index];
        const g = imageData.data[index + 1];
        const b = imageData.data[index + 2];

        const brightness = (r + g + b) / 3;
        totalBrightness += brightness;
        validCount++;
      }

      if (validCount === 0) return false;
      const avgBrightness = totalBrightness / validCount;
      return avgBrightness > 100;
    }

    function selectRectangleArea(startX, startY, endX, endY) {
      const [startCol, startRow] = screenToGrid(startX, startY);
      const [endCol, endRow] = screenToGrid(endX, endY);
      
      const minCol = Math.max(0, Math.min(startCol, endCol));
      const maxCol = Math.min(cols - 1, Math.max(startCol, endCol));
      const minRow = Math.max(0, Math.min(startRow, endRow));
      const maxRow = Math.min(rows - 1, Math.max(startRow, endRow));
      
      for (let col = minCol; col <= maxCol; col++) {
        for (let row = minRow; row <= maxRow; row++) {
          const key = `${col},${row}`;
          if (isLandCell(col, row) && !purchasedCells.has(key)) {
            selected.add(key);
          }
        }
      }
    }

    // Event listeners
    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      isDragging = true;
      dragStartX = x;
      dragStartY = y;
      dragCurrentX = x;
      dragCurrentY = y;
      
      e.preventDefault();
    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (isDragging) {
        dragCurrentX = x;
        dragCurrentY = y;
        draw(); 
      }

      const [col, row] = screenToGrid(x, y);
    });

    canvas.addEventListener("mouseup", e => {
      if (isDragging) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const dragDistance = Math.abs(x - dragStartX) + Math.abs(y - dragStartY);

        if (dragDistance < 5) {
          const [col, row] = screenToGrid(x, y);
          const key = `${col},${row}`;
          lastClickEl.textContent = `(${col}, ${row})`;

          if (!isLandCell(col, row)) {
            console.log("ðŸŒŠ Bu hÃ¼cre deniz veya sÄ±nÄ±r dÄ±ÅŸÄ±, seÃ§ilemez.");
          } else if (purchasedCells.has(key)) {
            console.log("ðŸŸ¢ Bu hÃ¼cre zaten satÄ±n alÄ±ndÄ±:", key);
          } else {
            if (selected.has(key)) {
              selected.delete(key);
              console.log("âŒ HÃ¼cre seÃ§imi kaldÄ±rÄ±ldÄ±:", key);
            } else {
              selected.add(key);
              console.log("âœ… HÃ¼cre seÃ§ildi:", key);
            }
          }
        } else {
          selectRectangleArea(dragStartX, dragStartY, x, y); 
          console.log("ðŸ“¦ Kutu alanÄ± seÃ§ildi");
        }

        isDragging = false;
        draw();
      }
    });

    canvas.addEventListener("mouseleave", e => {
      if (isDragging) {
        isDragging = false;
        draw();
      }
    });

    // SatÄ±n al butonuna tÄ±klama
    purchaseBtn.addEventListener("click", async () => {
      if (selected.size === 0) {
        alert("LÃ¼tfen Ã¶nce hÃ¼cre seÃ§in.");
        return;
      }

      const cellsArray = Array.from(selected);

      try {
        const saveRes = await fetch("/api/save-selection", {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken
          },
          body: JSON.stringify({ cells: cellsArray })
        });

        const saveText = await saveRes.text();
        if (!saveRes.ok) {
          console.error("âŒ Hata cevabÄ±:", saveText);
          alert("Hata: " + saveText);
          return;
        }

        const saveData = JSON.parse(saveText);
        console.log("âœ… HÃ¼creler kaydedildi:", saveData);

        // SatÄ±n alma sayfasÄ±na yÃ¶nlendir
        const selectedCellsParam = encodeURIComponent(JSON.stringify(cellsArray));
        window.location.href = `/purchase?cells=${selectedCellsParam}&count=${cellsArray.length}`;

      } catch (err) {
        alert("âŒ Sunucuya eriÅŸilemedi: " + err.message);
        console.error("Fetch hatasÄ±:", err);
      }
    });
    
    img.addEventListener("load", () => {
      console.log("GÃ¶rÃ¼ntÃ¼ yÃ¼klendi:", img.naturalWidth, "x", img.naturalHeight);
      resize();
      fetchPurchasedCells(); 
      fetchSelectedCells(); // SeÃ§ili hÃ¼creleri de yÃ¼kle
    });

    window.addEventListener("resize", resize);
    window.addEventListener("load", () => {
      resize();
    });
  </script>
</body>
</html>