<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Harita Se√ßimi (Antrasit)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      
      background: #0A1019;
background-image: url("https://www.transparenttextures.com/patterns/stardust.png");
        

    }

    #mapImage {
  -webkit-mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
  mask-image: radial-gradient(circle at center, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
}

    #container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #mapContainer {
      position: relative;
      max-width: 100%;
      max-height: 100%;
    }
    #mapImage {
      display: block;
      max-width: 100%;
      max-height: 100vh;
      object-fit: contain;
      background: #333;
    }
    #gridCanvas {
      position: absolute;
      top: 0; 
      left: 0;
      pointer-events: auto;
      cursor: crosshair;
    }
    #info {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial;
      z-index: 2;
    }
    #debug {
      position: absolute;
      bottom: 10px; left: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 2;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="mapContainer">
      <img id="mapImage" src="/static/app/map5.png" />
      <canvas id="gridCanvas"></canvas>
    </div>
    <div id="info">
      <div>Se√ßilen H√ºcre: <span id="selectedCount">0</span></div>
      <div>Son Tƒ±klama: <span id="lastClick">-</span></div>
    </div>
    <div id="debug">
      <div id="debugText">Harita y√ºkleniyor...</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gridCanvas");
    const ctx = canvas.getContext("2d");
    const selected = new Set();

    const cols = 1000;
    const rows = 1000;

    const img = document.getElementById("mapImage");
    const selectedCountEl = document.getElementById("selectedCount");
    const lastClickEl = document.getElementById("lastClick");
    const debugEl = document.getElementById("debugText");

    let imageDataCanvas = null;
    let imageCtx = null;
    let imageData = null;

    function resize() {
      // Canvas boyutunu img elementinin ger√ßek g√∂r√ºnt√ºlenen boyutuna e≈üitle
      const imgRect = img.getBoundingClientRect();
      canvas.width = imgRect.width;
      canvas.height = imgRect.height;

      // G√∂r√ºnt√º verilerini analiz etmek i√ßin ayrƒ± canvas
      if (!imageDataCanvas && img.naturalWidth > 0) {
        imageDataCanvas = document.createElement("canvas");
        imageDataCanvas.width = img.naturalWidth;
        imageDataCanvas.height = img.naturalHeight;
        imageCtx = imageDataCanvas.getContext("2d");
        
        // G√∂r√ºnt√ºy√º imageDataCanvas'a √ßiz
        imageCtx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
        imageData = imageCtx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);
      }

      debugEl.textContent = `Harita: ${img.naturalWidth}x${img.naturalHeight} | Canvas: ${canvas.width}x${canvas.height} | G√∂r√ºnt√ºlenen: ${Math.round(imgRect.width)}x${Math.round(imgRect.height)}`;
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const cellW = canvas.width / cols;
      const cellH = canvas.height / rows;

      ctx.fillStyle = "rgba(34,197,94,0.6)";
      ctx.strokeStyle = "rgba(34,197,94,0.8)";
      ctx.lineWidth = 1;

      selected.forEach(key => {
        const [x, y] = key.split(',').map(Number);
        ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
        if (canvas.width > 500) { // Grid √ßizgilerini sadece yeterli boyutta g√∂ster
          ctx.strokeRect(x * cellW, y * cellH, cellW, cellH);
        }
      });

      selectedCountEl.textContent = selected.size;
    }

    function isLandCell(col, row) {
      if (!imageData || !imageDataCanvas) return true; // Eƒüer g√∂r√ºnt√º y√ºklenmemi≈üse her yeri se√ßilebilir say
      
      const pixelList = [
        [0, 0],
        [-1, 0],
        [1, 0],
        [0, -1],
        [0, 1]
      ];

      let totalBrightness = 0;
      let validCount = 0;

      for (const [dx, dy] of pixelList) {
        const sampleX = Math.floor((col + 0.5 + dx) * (imageDataCanvas.width / cols));
        const sampleY = Math.floor((row + 0.5 + dy) * (imageDataCanvas.height / rows));

        if (sampleX < 0 || sampleX >= imageDataCanvas.width ||
            sampleY < 0 || sampleY >= imageDataCanvas.height) continue;

        const index = (sampleY * imageDataCanvas.width + sampleX) * 4;
        const r = imageData.data[index];
        const g = imageData.data[index + 1];
        const b = imageData.data[index + 2];

        const brightness = (r + g + b) / 3;
        totalBrightness += brightness;
        validCount++;
      }

      if (validCount === 0) return false;
      const avgBrightness = totalBrightness / validCount;
      return avgBrightness > 100; // e≈üik
    }

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const col = Math.floor((x / canvas.width) * cols);
      const row = Math.floor((y / canvas.height) * rows);
      const key = `${col},${row}`;

      lastClickEl.textContent = `(${col}, ${row})`;

      if (!isLandCell(col, row)) {
        console.log("üåä Bu h√ºcre deniz, se√ßilemez.");
        return;
      }

      if (selected.has(key)) {
        selected.delete(key);
        console.log("‚ùå H√ºcre se√ßimi kaldƒ±rƒ±ldƒ±:", key);
      } else {
        selected.add(key);
        console.log("‚úÖ H√ºcre se√ßildi:", key);
      }

      draw();
    });

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const col = Math.floor((x / canvas.width) * cols);
      const row = Math.floor((y / canvas.height) * rows);

      if (col >= 0 && col < cols && row >= 0 && row < rows) {
        // Mouse pozisyonu debug bilgisi i√ßin kullanƒ±labilir
      }
    });

    // G√∂r√ºnt√º y√ºklendiƒüinde resize √ßaƒüƒ±r
    img.addEventListener("load", () => {
      console.log("G√∂r√ºnt√º y√ºklendi:", img.naturalWidth, "x", img.naturalHeight);
      resize();
    });

    // Pencere boyutu deƒüi≈ütiƒüinde resize √ßaƒüƒ±r
    window.addEventListener("resize", resize);

    // ResizeObserver ile img elementinin boyut deƒüi≈üikliklerini izle
    if (window.ResizeObserver) {
      const resizeObserver = new ResizeObserver(entries => {
        resize();
      });
      resizeObserver.observe(img);
    }

    // Sayfa y√ºklendiƒüinde ba≈ülat
    window.addEventListener("load", () => {
      resize();
    });
  </script>
</body>
</html>